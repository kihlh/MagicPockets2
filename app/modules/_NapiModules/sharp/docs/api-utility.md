<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

## format(格式)

一个包含嵌套布尔值的对象，代表可用的输入和输出格式/方法。

### Examples

```javascript
console.log(sharp.format);
```

返回类型**[Object][1]** 

## interpolators(插值器)

一个包含可用插值器及其适当值的对象

类型： [string][2]

### nearest(近邻内插法 硬边缘)

[Nearest neighbour interpolation][3]. 仅适用于图像放大。

### bilinear(两次线性)

[Bilinear interpolation][4]. 比双曲线更快，但结果不那么平滑。

### bicubic(二次立方)

[Bicubic interpolation][5] (当前使用).

### locallyBoundedBicubic(LBB插值)

[LBB插值][6]。防止一些"[acutance][7]"，但通常会降低2倍的性能。

### nohalo

[Nohalo插值][8]。防止尖锐化，但通常会降低3倍的性能。

### vertexSplitQuadraticBasisSpline（VSQBS插值）

[VSQBS插值][9]。防止放大时出现 "阶梯状"。

## versions(版本号)

一个包含 libvips 及其依赖关系的版本号的对象。

### Examples(演示)

```javascript
console.log(sharp.versions);
```

## vendor(平台和架构)

一个包含平台和架构的对象
的平台和架构。

### Examples(演示)

```javascript
console.log(sharp.vendor);
```

## cache(缓存)

获取或在提供选项的情况下，设置 libvips 操作缓存的限制。
缓存中的现有条目将在限制的任何变化后被修剪。
这个方法总是返回缓存的统计数据。
对于确定某项任务需要多少工作内存是很有用的。

### cc

*   `options` **([Object][1] | [boolean][10])** 具有以下属性的对象，或布尔值，其中true使用默认缓存设置，false删除所有缓存 (可选, 默认 `true`)
    *   `options.memory` **[number][11]** 是用于该缓存的最大内存（MB）（可选，默认为``50``）。
    *   `options.files` **[number][11]** 是要保持开放的最大文件数（可选，默认为 `20`)
    *   `options.items` **[number][11]** 是要缓存的最大操作数（可选，默认为 `100`)

### Examples(演示)

```javascript
const stats = sharp.cache();
```

```javascript
sharp.cache( { items: 200 } );
sharp.cache( { files: 0 } );
sharp.cache(false);
```

返回值： **[Object][1]** 

## concurrency（并发性）

获取，或者当提供了一个并发数时，设置
*libvips*应该使用的最大线程数来处理*每个图像*。
这些是由glib管理的线程池。
这有助于避免创建新线程的开销。

这个方法总是返回当前的并发量。

默认值是CPU核的数量。
除非使用基于glibc的Linux，没有jemalloc。
时，默认值为`1`，以帮助减少内存碎片。

`0`的值将重置为CPU核心的数量。

一些图像格式库会产生额外的线程。
例如，libaom在编码AVIF图像时管理自己的4个线程。
而这些与这里设置的值无关。

sharp可以并行处理的最大图像数
是由libuv的`UV_THREADPOOL_SIZE`环境变量控制的。
它的默认值是4。

[https://nodejs.org/api/cli.html#uv_threadpool_sizesize][12]

例如，在默认情况下，一台有8个CPU核心的机器将处理
4个图像的并行处理，每个图像最多使用8个线程。
所以会有多达32个并发的线程。

### 参数

*   `concurrency` **[number][11]?** 

### Examples(演示)

```javascript
const threads = sharp.concurrency(); // 4
sharp.concurrency(2); // 2
sharp.concurrency(0); // 4
```

返回值 **[number][11]** 并发数

## queue

* 一个EventEmitter，当一个任务处于以下两种情况之一时，会发出一个变化事件。

  排队，等待libuv提供一个工作线程

  已完成

### Examples(演示)

```javascript
sharp.queue.on('change', function(queueLength) {
  console.log('Queue contains ' + queueLength + ' task(s)');
});
```

## counters(计数器)

提供对内部任务计数器的访问。

*   queue 是这个模块排队等待libuv从其池子里提供一个工作线程的任务数量。
*   process 是指当前正在处理的调整大小的任务数。

### Examples(实例/并发/限制)

```javascript
const counters = sharp.counters(); // { queue: 2, process: 4 }
```

返回值**[Object][1]** 

## simd(向量单位指令)

获取和设置SIMD向量单元指令的使用。
要求 libvips 在编译时已支持 liborc。

通过利用CPU的SIMD向量单元，如英特尔SSE和锐化单元，提高了调整大小、模糊和锐化操作的性能。
通过利用CPU的SIMD向量单元，例如Intel SSE和ARM NEON，提高调整大小和模糊的性能。

### Parameters(参数)

*   `simd` **[boolean][10]**  (选项, 默认`true`)

### Examples(演示)

```javascript
const simd = sharp.simd();
// 如果当前启用了liborc的运行时使用，simd为`true`。
```

```javascript
const simd = sharp.simd(false);
// 防止 libvips 在运行时使用 liborc
```

返回值 **[boolean][10]** 

[1]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object

[2]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String

[3]: http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation

[4]: http://en.wikipedia.org/wiki/Bilinear_interpolation

[5]: http://en.wikipedia.org/wiki/Bicubic_interpolation

[6]: https://github.com/libvips/libvips/blob/master/libvips/resample/lbb.cpp#L100

[7]: http://en.wikipedia.org/wiki/Acutance

[8]: http://eprints.soton.ac.uk/268086/

[9]: https://github.com/libvips/libvips/blob/master/libvips/resample/vsqbs.cpp#L48

[10]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean

[11]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number

[12]: https://nodejs.org/api/cli.html#uv_threadpool_sizesize
